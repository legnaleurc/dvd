#! /usr/bin/env python3

import asyncio
import argparse
import os
import pathlib
import signal
import sys


PUBLIC_PORT = 8000
PRIVATE_PORT = 9000


class ProcessError(Exception):

    def __init__(self, rv):
        self._rv = rv

    def __str__(self):
        return f'failed with code: {self._rv}'


async def main(args=None):
    if args is None:
        args = sys.argv

    setup()

    args = parse_args(args)

    try:
        if not args.debug:
            await run_release(
                public_listen=args.public_listen,
                token=args.token,
            )
        else:
            await run_debug(
                public_listen=args.public_listen,
                private_listen=args.private_listen,
                token=args.token,
            )
    except Exception as e:
        print(e)
        return 1

    return 0


def setup():
    loop = asyncio.get_running_loop()
    loop.add_signal_handler(signal.SIGINT, close)


def close():
    pass


def parse_args(args):
    parser = argparse.ArgumentParser('dvd')
    parser.add_argument('-d', '--debug', action='store_true')
    parser.add_argument('--public-listen', type=int, default=PUBLIC_PORT)
    parser.add_argument('--private-listen', type=int, default=PRIVATE_PORT)
    parser.add_argument('--token', type=str)
    args = parser.parse_args(args[1:])
    return args


async def run_release(public_listen: int, token: str):
    await run_or_die(['make', '-j'])
    cmd = [
        'python3', '-m', 'engine',
            '-u', '../unpack/build/unpack',
            '-s', '../viewer/build',
            '-p', str(public_listen),
    ]
    if token:
        cmd.extend(['-t', token])
    await run_or_die(cmd, cwd=pathlib.Path('./engine'))


async def run_debug(
    public_listen: int,
    private_listen: int,
    token: str,
):
    await run_or_die(['make', '-j', 'debug'])

    cmd = [
        'python3', '-m', 'wcpan.watchdog',
            '--',
            'python3', '-m', 'engine',
                '-u', '../unpack/build/unpack',
                '-p', str(private_listen),
    ]
    if token:
        cmd.extend(['-t', token])
    backend_process = await spawn(
        cmd,
        cwd=pathlib.Path('./engine'),
    )
    backend_task = asyncio.create_task(ok_or_die(backend_process))

    cmd = [
        'npm', 'run', 'dev', '--',
            '--host=0.0.0.0',
            f'--port={public_listen}',
    ]
    frontend_process = await spawn(
        cmd,
        cwd=pathlib.Path('./viewer'),
        env=clone_env({
            'BACKEND_BASE_URL': f'http://localhost:{private_listen}',
        }),
    )
    frontend_task = asyncio.create_task(ok_or_die(frontend_process))

    backend_task.add_done_callback(lambda _: kill_process(frontend_process))
    frontend_task.add_done_callback(lambda _: kill_process(backend_process))

    await asyncio.wait([
        backend_task,
        frontend_task,
    ])


async def run_or_die(cmd, cwd=None, env=None) -> None:
    p = await spawn(cmd, cwd=cwd, env=env)
    await ok_or_die(p)


async def spawn(cmd, cwd=None, env=None) -> asyncio.subprocess.Process:
    return await asyncio.create_subprocess_exec(*cmd, cwd=cwd, env=env)


async def ok_or_die(p: asyncio.subprocess.Process):
    rv = await p.wait()
    if rv > 0:
        raise ProcessError(rv)


def clone_env(override=None) -> dict[str, str]:
    env = os.environ.copy()
    if override:
        env.update(override)
    return env


def kill_process(p: asyncio.subprocess.Process):
    if p.returncode is not None:
        return
    p.send_signal(signal.SIGINT)


if __name__ == '__main__':
    sys.exit(asyncio.run(main()))
