#! /usr/bin/env python3

import asyncio
import argparse
import os
import pathlib
import signal
import sys


PUBLIC_PORT = 8000
PRIVATE_PORT = 9000


class ProcessError(Exception):

    def __init__(self, rv):
        self._rv = rv

    def __str__(self):
        return f'failed with code: {self._rv}'


async def main(args=None):
    if args is None:
        args = sys.argv

    setup()

    args = parse_args(args)

    try:
        if not args.debug:
            await run_release(public_listen=args.public_listen)
        else:
            await run_debug(public_listen=args.public_listen,
                            private_listen=args.private_listen)
    except Exception as e:
        print(e)
        return 1

    return 0


def close(*args, **kwargs):
    pass


def setup():
    loop = asyncio.get_running_loop()
    loop.add_signal_handler(signal.SIGINT, close)
    loop.add_signal_handler(signal.SIGTERM, close)


def parse_args(args):
    parser = argparse.ArgumentParser('dvd')
    parser.add_argument('-d', '--debug', action='store_true')
    parser.add_argument('--public-listen', type=int, default=PUBLIC_PORT)
    parser.add_argument('--private-listen', type=int, default=PRIVATE_PORT)
    args = parser.parse_args(args[1:])
    return args


async def run_release(public_listen):
    await run_or_die(['make', '-j'])
    await run_or_die([
        'python3', '-m', 'engine',
            '-u', 'unpack/build/unpack',
            '-s', 'viewer/dist',
            '-l', str(public_listen),
    ])


async def run_debug(public_listen, private_listen):
    await run_or_die(['make', '-j', 'debug'])

    ps = [
        await cspe(
            [
                'python3', '-m', 'watchgod',
                    'engine.main.from_env',
                    './engine',
            ],
            env=clone_env({
                'ENGINE_UNPACK': 'unpack/build/unpack',
                'ENGINE_LISTEN': str(private_listen),
            }),
        ),
        await cspe(
            [
                'yarn', 'start',
                    f'--port={public_listen}',
            ],
            cwd=pathlib.Path('./viewer'),
            env=clone_env({
                'BACKEND_PORT': str(private_listen),
            }),
        ),
    ]
    rv = await run_all(ps)
    assert rv


async def cspe(cmd, cwd=None, env=None):
    return await asyncio.create_subprocess_exec(*cmd, cwd=cwd, env=env)


async def ok_or_die(p):
    rv = await p.wait()
    if rv > 0:
        raise ProcessError(rv)


async def run_or_die(cmd, cwd=None, env=None):
    p = await cspe(cmd, cwd=cwd, env=env)
    await ok_or_die(p)


async def run_all(ps):
    aws = [asyncio.create_task(ok_or_die(p)) for p in ps]
    done, pending = await asyncio.wait(aws, return_when=asyncio.FIRST_EXCEPTION)
    if not pending:
        return True

    for t in done:
        assert not t.cancelled()
        if t.exception():
            print(t.exception())

    for p in ps:
        if p.returncode is None:
            p.send_signal(signal.SIGTERM)

    done, pending = await asyncio.wait(pending)

    for t in done:
        assert not t.cancelled()
        if t.exception():
            print(t.exception())

    return False


def clone_env(override=None):
    env = os.environ.copy()
    if override:
        env.update(override)
    return env


if __name__ == '__main__':
    sys.exit(asyncio.run(main()))
